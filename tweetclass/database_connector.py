from .models import Query, Query_data, Tweet
import time
import threading
from django.utils import timezone
from django.shortcuts import get_object_or_404

'''
 This is used to connect to the database through a lock in order to 
 avoid  different threads to access at the same time.
''' 

def connect_db(raw_tweets=[],clas_tweets=[],requested_query="",query_text_search="",flag=0,requested_query_data_id=0):
    cont=0
    #add the tweets to the database
    if flag==2:
        time.sleep(2)
    
    lock = threading.Lock()
    
    lock.acquire()
    try:
        if flag==0: # The acces to the database to obtain the query that was made
            try:
                #if it does exist we obtain the query id
                requested_query = Query.objects.get(query_text=query_text_search)
            except Query.DoesNotExist:
                #else create it and obtain the id 
                requested_query = Query(query_text=query_text_search)
        elif flag==1: # The results of the classification have to be stored
            # hm will contain the total amount of tweets retreived for a concrete query
            hm = float(len(clas_tweets)) 
            print("storing results")
            requested_query_data=requested_query.query_data_set.create(
                query_date=timezone.now(),
                p_pos_p=clas_tweets.count("P+")*100.0/hm,
                p_pos=clas_tweets.count("P")*100/hm,
                p_neu=clas_tweets.count("NEU")*100/hm,
                p_neg=clas_tweets.count("N")*100/hm,
                p_neg_p=clas_tweets.count("N+")*100/hm,
                p_none=clas_tweets.count("NONE")*100/hm,
            )
            print("results stored")
        elif flag==2: # The tweets have to be stored in the database
            print("about to save in the db")
            start = time.time()
            for tweet in raw_tweets:
                # If the tweet doesn't exist, add it
                # we have to check this because the ID isn't autogenerated
                # but instead, we are using the tweeter ID and adding it manually
                if not (requested_query.tweet_set.filter(pk=tweet[0]).exists()):
                    requested_query.tweet_set.create(
                        #~ tweet_text=tweet[2],
                        #~ tweet_text="",
                        id=tweet[0],
                        tweet_pol=clas_tweets[cont]
                    )
                cont+=1
            end = time.time()
            print("%d tweets succesfully saved in %s seconds" % (cont, end-start) )
        elif flag==3: # Retreive the information of a concrete query in order to show the results
            current_query = Query_data.objects.get(pk=requested_query_data_id)
            query = get_object_or_404(Query,pk=current_query.query_id_id)
            all_results = query.query_data_set.all()
        
        if not flag==3:
            requested_query.save()
    finally:
        lock.release()
    
    # return if necessary
    if flag==0:
        return requested_query
    elif flag==1:
        return requested_query_data
    elif flag==3:
        return current_query,query,all_results
